{
    "docs": [
        {
            "location": "/", 
            "text": "Tutorials\n\n\nThis section provides tutorials that walk you through using Ballerina. If you have not already taken the \nQuick Tour\n, please do so now to get up and running quickly before you start the tutorials. \n\n\n\n\nWrite your First Program\n\n\nWrite a Main Program\n\n\nWrite a Passthrough Service\n\n\nCreate a Custom Client Connector\n\n\nCreate an Archive of your Program\n\n\nCreate a Docker Image with a Ballerina Program", 
            "title": "Architecture Design Documents"
        }, 
        {
            "location": "/#tutorials", 
            "text": "This section provides tutorials that walk you through using Ballerina. If you have not already taken the  Quick Tour , please do so now to get up and running quickly before you start the tutorials.    Write your First Program  Write a Main Program  Write a Passthrough Service  Create a Custom Client Connector  Create an Archive of your Program  Create a Docker Image with a Ballerina Program", 
            "title": "Tutorials"
        }, 
        {
            "location": "/tutorials/create-archive/", 
            "text": "Create an Archive of your Program\n\n\nYou can execute Ballerina programs (\n.bal\n files) directly from the command line. However, if you want to create a self-contained package containing all the program code and third-party dependencies, you must build the program into a packaged format: a \nservice archive\n \n.bsz\n (if your program's logic is defined as a service) or \nexecutable archive\n \n.bmz\n (if your program's logic is defined in the \nmain()\n function). For example, if you want to deploy your Ballerina service to \nWSO2 Integration Cloud\n so that others can access that service in the cloud, you create a service archive of your Ballerina program and upload it to the cloud. This tutorial shows you how to create an archive of the HelloWorldService sample. \n\n\nDeclare the package name\n\n\nBefore you can create your archive, you must declare a package name for your Ballerina program. This package name provides a unique identifier for your program. The path in the package name must match the directory structure where the Ballerina file is located, starting from the top directory where your programs are located. For example, if you want to create archives of the Ballerina sample programs, you would declare the package names in each of the samples as \nsamples.\nsampleName\n, such as \nsamples.helloWorldService\n. When you create an archive of your program, you will use the package name with the \nballerina build\n command to specify which program you want to archive.\n\n\nYou declare the package name at the very top of the Ballerina program file. Let's declare a package name for the HelloWorldService sample.\n\n\n\n\nIn your \nballerina_home\n/samples/helloWorldService\n directory, open the \nhelloWorldService.bal\n file for editing. You can use the Composer or any text editor.\n\n\nAt the top of the file, add the following line to declare the package name:\n\n\n\n\npackage samples.helloWorldService;\n\n\n\n\nThe sample should now look like this:\n\n\npackage samples.helloWorldService;\nimport ballerina.lang.messages;\n@http:BasePath (\n/hello\n)\nservice helloWorld {\n\n    @http:GET\n    resource sayHello (message m) {\n        message response = {};\n        messages:setStringPayload(response, \nHello, World!\n);\n        reply response;\n\n    }\n\n}\n\n\n\n\nNow that you have declared the package name for the HelloWorldService program, you can build an archive of it by specifying its package name.\n\n\nCreate the archive\n\n\nTo create the archive, you will use the \nballerina build\n command followed by the archive type (\nservice\n or \nmain\n), specify one or more packages to include in the archive, and optionally specify the output name to give the archive file. When you specify the package name in this command, note that you will use slashes instead of periods to delineate the path, such as \nsamples/helloWorldService\n instead of \nsamples.helloWorldService\n. If you don't specify an output name for the archive file, the last part of the package name is used as the name, e.g., \nhelloWorldService.bsz\n. In this tutorial, we will name the archive file \nhello.bsz\n.\n\n\nLet's create the archive.\n\n\n\n\nNavigate to your \nballerina_home\n directory.\n\n\nIf your \nballerina_home\n/bin\n directory is already in your path, type the \nballerina\n command as shown below. If it's not in your path, type \nbin/ballerina\n (or \nbin\\ballerina\n on Windows) instead of \nballerina\n. \n\n\n\n\nballerina build service samples/helloWorldService -o hello.bsz\n\n\nYou now have a service archive file of your Ballerina program, which you can upload to WSO2 Integration Cloud, run in a Docker container, or distribute to other Ballerina users.", 
            "title": "create-archive"
        }, 
        {
            "location": "/tutorials/create-archive/#create-an-archive-of-your-program", 
            "text": "You can execute Ballerina programs ( .bal  files) directly from the command line. However, if you want to create a self-contained package containing all the program code and third-party dependencies, you must build the program into a packaged format: a  service archive   .bsz  (if your program's logic is defined as a service) or  executable archive   .bmz  (if your program's logic is defined in the  main()  function). For example, if you want to deploy your Ballerina service to  WSO2 Integration Cloud  so that others can access that service in the cloud, you create a service archive of your Ballerina program and upload it to the cloud. This tutorial shows you how to create an archive of the HelloWorldService sample.", 
            "title": "Create an Archive of your Program"
        }, 
        {
            "location": "/tutorials/create-archive/#declare-the-package-name", 
            "text": "Before you can create your archive, you must declare a package name for your Ballerina program. This package name provides a unique identifier for your program. The path in the package name must match the directory structure where the Ballerina file is located, starting from the top directory where your programs are located. For example, if you want to create archives of the Ballerina sample programs, you would declare the package names in each of the samples as  samples. sampleName , such as  samples.helloWorldService . When you create an archive of your program, you will use the package name with the  ballerina build  command to specify which program you want to archive.  You declare the package name at the very top of the Ballerina program file. Let's declare a package name for the HelloWorldService sample.   In your  ballerina_home /samples/helloWorldService  directory, open the  helloWorldService.bal  file for editing. You can use the Composer or any text editor.  At the top of the file, add the following line to declare the package name:   package samples.helloWorldService;  The sample should now look like this:  package samples.helloWorldService;\nimport ballerina.lang.messages;\n@http:BasePath ( /hello )\nservice helloWorld {\n\n    @http:GET\n    resource sayHello (message m) {\n        message response = {};\n        messages:setStringPayload(response,  Hello, World! );\n        reply response;\n\n    }\n\n}  Now that you have declared the package name for the HelloWorldService program, you can build an archive of it by specifying its package name.", 
            "title": "Declare the package name"
        }, 
        {
            "location": "/tutorials/create-archive/#create-the-archive", 
            "text": "To create the archive, you will use the  ballerina build  command followed by the archive type ( service  or  main ), specify one or more packages to include in the archive, and optionally specify the output name to give the archive file. When you specify the package name in this command, note that you will use slashes instead of periods to delineate the path, such as  samples/helloWorldService  instead of  samples.helloWorldService . If you don't specify an output name for the archive file, the last part of the package name is used as the name, e.g.,  helloWorldService.bsz . In this tutorial, we will name the archive file  hello.bsz .  Let's create the archive.   Navigate to your  ballerina_home  directory.  If your  ballerina_home /bin  directory is already in your path, type the  ballerina  command as shown below. If it's not in your path, type  bin/ballerina  (or  bin\\ballerina  on Windows) instead of  ballerina .    ballerina build service samples/helloWorldService -o hello.bsz  You now have a service archive file of your Ballerina program, which you can upload to WSO2 Integration Cloud, run in a Docker container, or distribute to other Ballerina users.", 
            "title": "Create the archive"
        }, 
        {
            "location": "/tutorials/create-docker-container/", 
            "text": "Create a Docker Image with a Ballerina Program\n\n\nBusinesses and enterprises worldwide are now faced with the challenge of digital transformation. However, digital transformation has to be implemented under certain restrictions related to existing applications and infrastructure. Docker plays a key role in digital transformation by creating independance between applications and infrastructure and enabling them all to collaborate easily. A Docker container is a stand-alone piece of software that comes in a lightweight, runnable, executable package.\n\n\n\n\nThis tutorial explores the methods used to create a docker container that has a Ballerina service embedded within. Ballerina supports dockerizing out-of-the-box.\n\n\n\n\nThis tutorial includes instructions of creating a Docker image using the following methods.\n\n\n\n\nCreate your own Docker image\n\n\nAdding your services to an existing Docker container\n\n\n\n\n\n\nPrerequisites\n: You need to have Docker configured and running. Some expertise with cURL commands will also be useful. For more information on starting up and the Ballerina Composer, see \nQuick Tour\n.\n\n\n\n\nCreate your own Docker image\n\n\n\n\nFirst download the Ballerina tools distribution. The latest Ballerina pack can be found at: https://ballerinalang.org/downloads/\n\n\nExtract the downloaded .zip file, set up the Ballerina runtime, and run Ballerina. For more information on how to do this, see \nQuick Tour\n.\n\n\n\n\nCreate a Ballerina service to be added to the Docker container. Create the following service in the Ballerina Composer \nSource View\n (you can alternatively create a main function). Name the file: \ndocker-service.bal\n.\n    ```\n    import ballerina.net.http;\n\n\n@http:configuration {basePath:\"/echo\"}\nservice\n echo {\n\n\n@http:resourceConfig {\n    methods:[\"POST\"],\n    path:\"/\"\n}\nresource echo (http:Request req, http:Response resp) {\n    string payload = req.getStringPayload();\n    resp.setStringPayload(payload);\n    resp.send();\n}\n\n\n\n}\n\n1. Create the Docker image using the following command.\n\nballerina docker docker-service.bal\n\nIf the above command succeeds you can see something similar to the following.\n![alt text](../images/DockerImage1.png)\n1. To verify image creation, execute the following command, which lists all the images in local docker registry.\n\ndocker images\n\n1. Start the container with the following command.\n\ndocker run -p 39165:9090 --name docker-sample -d docker-service:latest\n\n\n1. The service should be up and running. You can verify this by listing all the docker processes.\n\ndocker ps\n\n1. Invoke the service with following command.\n\ncurl -X POST http://localhost:39165/echo -d 'This is a sample message'\n```\nIf everything is successful, you can see the echoed response from the Ballerina server.\n\n\n\n\n\n\nAdding your services to an existing Docker container\n\n\nThe Docker distribution for Ballerina is available on Docker Hub as ballerinalang/ballerina. To run a Ballerina package using the Ballerina Docker image, simply mount the folder containing the file to /ballerina/files folder inside the container. The following steps have instructions on how you can do this.\n\n\n\n\nPull the ballerina docker image using the following command.\n      \ndocker pull ballerinalang/ballerina\n\n\nCreate a directory and copy the packages needed to be run.\n      \nmkdir -p ~/ballerina/service/\n\n\n\n\nAdd the following service to ~/ballerina/service\n    ```\n    import ballerina.net.http;\n\n\n@http:configuration {basePath:\"/echo\"}\nservice\n echo {\n\n\n@http:resourceConfig {\n    methods:[\"POST\"],\n    path:\"/\"\n}\nresource echo (http:Request req, http:Response resp) {\n    string payload = req.getStringPayload();\n    resp.setStringPayload(payload);\n    resp.send();\n}\n\n\n\n}\n\n1. Mount the volume and start the Docker container.\n\ndocker run -v ~/ballerina/service:/ballerina/files -p 9090:9090 -it ballerinalang/ballerina:0.95.0\n\n1. Now invoke the service with following cURL command.\n\ncurl -X POST http://localhost:9090/echo -d 'This is a sample message'\n```\nIf everything is successful, you can see the echoed response from the Ballerina server", 
            "title": "create-docker-container"
        }, 
        {
            "location": "/tutorials/create-docker-container/#create-a-docker-image-with-a-ballerina-program", 
            "text": "Businesses and enterprises worldwide are now faced with the challenge of digital transformation. However, digital transformation has to be implemented under certain restrictions related to existing applications and infrastructure. Docker plays a key role in digital transformation by creating independance between applications and infrastructure and enabling them all to collaborate easily. A Docker container is a stand-alone piece of software that comes in a lightweight, runnable, executable package.   This tutorial explores the methods used to create a docker container that has a Ballerina service embedded within. Ballerina supports dockerizing out-of-the-box.   This tutorial includes instructions of creating a Docker image using the following methods.   Create your own Docker image  Adding your services to an existing Docker container    Prerequisites : You need to have Docker configured and running. Some expertise with cURL commands will also be useful. For more information on starting up and the Ballerina Composer, see  Quick Tour .", 
            "title": "Create a Docker Image with a Ballerina Program"
        }, 
        {
            "location": "/tutorials/create-docker-container/#create-your-own-docker-image", 
            "text": "First download the Ballerina tools distribution. The latest Ballerina pack can be found at: https://ballerinalang.org/downloads/  Extract the downloaded .zip file, set up the Ballerina runtime, and run Ballerina. For more information on how to do this, see  Quick Tour .   Create a Ballerina service to be added to the Docker container. Create the following service in the Ballerina Composer  Source View  (you can alternatively create a main function). Name the file:  docker-service.bal .\n    ```\n    import ballerina.net.http;  @http:configuration {basePath:\"/echo\"}\nservice  echo {  @http:resourceConfig {\n    methods:[\"POST\"],\n    path:\"/\"\n}\nresource echo (http:Request req, http:Response resp) {\n    string payload = req.getStringPayload();\n    resp.setStringPayload(payload);\n    resp.send();\n}  } 1. Create the Docker image using the following command. \nballerina docker docker-service.bal If the above command succeeds you can see something similar to the following.\n![alt text](../images/DockerImage1.png)\n1. To verify image creation, execute the following command, which lists all the images in local docker registry. \ndocker images 1. Start the container with the following command. \ndocker run -p 39165:9090 --name docker-sample -d docker-service:latest  1. The service should be up and running. You can verify this by listing all the docker processes. \ndocker ps 1. Invoke the service with following command. \ncurl -X POST http://localhost:39165/echo -d 'This is a sample message'\n```\nIf everything is successful, you can see the echoed response from the Ballerina server.", 
            "title": "Create your own Docker image"
        }, 
        {
            "location": "/tutorials/create-docker-container/#adding-your-services-to-an-existing-docker-container", 
            "text": "The Docker distribution for Ballerina is available on Docker Hub as ballerinalang/ballerina. To run a Ballerina package using the Ballerina Docker image, simply mount the folder containing the file to /ballerina/files folder inside the container. The following steps have instructions on how you can do this.   Pull the ballerina docker image using the following command.\n       docker pull ballerinalang/ballerina  Create a directory and copy the packages needed to be run.\n       mkdir -p ~/ballerina/service/   Add the following service to ~/ballerina/service\n    ```\n    import ballerina.net.http;  @http:configuration {basePath:\"/echo\"}\nservice  echo {  @http:resourceConfig {\n    methods:[\"POST\"],\n    path:\"/\"\n}\nresource echo (http:Request req, http:Response resp) {\n    string payload = req.getStringPayload();\n    resp.setStringPayload(payload);\n    resp.send();\n}  } 1. Mount the volume and start the Docker container. \ndocker run -v ~/ballerina/service:/ballerina/files -p 9090:9090 -it ballerinalang/ballerina:0.95.0 1. Now invoke the service with following cURL command. \ncurl -X POST http://localhost:9090/echo -d 'This is a sample message'\n```\nIf everything is successful, you can see the echoed response from the Ballerina server", 
            "title": "Adding your services to an existing Docker container"
        }, 
        {
            "location": "/tutorials/custom-client-connector/", 
            "text": "Create a Custom Client Connector\n\n\nNow that you have \nwritten a main program\n and \nwritten a passthrough service\n for integration scenarios, it is time to write a custom client connector to solve a problem.\n\n\n\n\nThis tutorial provides instructions on how to write a custom connector that invokes \nGitHub REST APIs\n.\n\n\n\n\nThis tutorial consists of the following main sections.\n\n\n\n\nAbout connectors and actions\n\n\nAbout custom client connectors\n\n\nCreate a custom client connector\n\n\n\n\n\n\nPrerequisites\n: Download Ballerina and set it up. For instructions on how to do this, see the \nQuick Tour\n. Use the Quick Tour to also get an understanding of the Ballerina Composer and how it works. It is also recommended to try to \nwrite a main program\n and \nwrite a passthrough service\n before trying this out. This helps you to get familiar with Ballerina and how it can help achieve integration scenarios.\n\n\n\n\nAbout connectors and actions\n\n\nWhen integrating and making a robust application, a need arises to make messaging channels in between various interfaces and weave a structure to encompass them together. When interacting with commonly available interfaces, rather than creating the structure of the messaging channel each and every time through code, it is worth keeping a programmed unit that can be reused. This component interacts with the given interface with ease and less complexity. In a way, such a unit can be described as a facade as it will mask any complexities that exist when interacting with the real interface and can be a facade to any party connecting to the particular interface.\n\n\nBallerina brings out a concept called connectors that makes the above possible with ease. Using Ballerina connectors, a custom Ballerina implementation can be made that can be used to communicate with a given interface. This custom connector can be made out-of-the-box just using Ballerina itself. The use of these custom connectors can span from a database to a REST endpoint and can even extend to a JMS queue as the requirement demands.\n\n\nConnectors represents network services that are used by a Ballerina program. The term \"network services\" here is meant in the broadest possible sense - Ballerina is designed to connect with everything from a database to a JMS queue to an OAuth protected API to LDAP servers and more. Therefore, connectors are the representation of any such remote service in Ballerina.\n\n\nGraphically, connectors are modeled as a separate lifeline to represent their independent and parallel execution. However, that lifeline is not a programmable thread of execution for the Ballerina developer - it only exists to represent the remote system.\n\n\nConnectors may need to have usage specific parameters and, hence, must be instantiated prior to use. For example, an HTTP connector needs at least the URL to connect to.\n\n\nA connector comes with a set of actions that represent the interactions that one can have with the remote service. Actions can be one directional or bi-directional and represent blocking from the calling worker's perspective. That is, the calling thread is blocked until the action has completed its remote interaction.\n\n\nA connector contains the following syntax in Ballerina.\n\n\n[ConnectorAnnotations]\n[public] connector ConnectorName ([Connector initialize parameters]) {\n    VariableDeclaration;*\n    ActionDefinition;+\n}\n\n\n\n\n\nAny variables declared at the connector level is visible to all actions. The lifetime of the connector also defines the lifetime of the variables and they are local to each connector instance.\n\n\nThe structure of an action definition is as follows.\n\n\n[ActionAnnotations]\naction actionName ([Input parameters]) ([Output parameters]){\n}\n\n\n\n\n\nThe execution semantics of an action are the same as that of a function: it runs using the caller's thread and the caller blocks until the action completes execution.\n\n\nAbout custom client connectors\n\n\nWhen creating a custom client connector, you need to be aware of the following.\n\n\n\n\nThe capabilities you need to expose through the connector and logical separation. These is represented by separate actions when the connector is being created.\n\n\nSupportive extensions needed. These can be achieved by Ballerina itself or by integrating to an existing entity through Ballerina\n\n\nPackaging the connector \n\n\n\n\nIn order to demonstrate the above aspects, this tutorial uses a connector that can invoke GitHub REST APIs. GitHub contains a set of REST APIs that can be used to achieve a vast set of functionalities. Out of the collection, REST APIs that cover the following functionalities are used.\n\n\n\n\nView repositories for the authenticated user\n.\n\n\nList repositories for an organization\n.\n\n\nList issues per repository according to the state\n\n\n\n\nThe above can be categorized as the capabilities expected from the connector and these are represented by separate actions.\n\n\nFurthermore, in order to invoke the APIs, an authentication header must be sent that encompasses the base64 encoded value of the username and the token. This is a supportive extension and can be powered by Ballerina itself by using its inbuilt \nbase64encoder\n.\n\n\nAfter creating the connector, you need to package it in a way that the connector can be distributed. As a comprehensive packaging mechanism is work in progress, currently we will be using the available packaging model to demonstrate the usage of the connector. The reason for using the package is that, when the inbuilt packaging is available, the structure available now can be extended and packaged to a distributable mode.\n\n\nCreate a custom client connector\n\n\nThis section of the tutorial explains the way a sample custom client connector is built.\n\n\n\n\n\n\nOn the tool palette, click \nMore Connectors\n to see a list of all available connectors.\n    \n\n\n\n\n\n\nFrom the list that appears, expand \nballerina.net.http\n and drag a \nClientConnector\n onto the canvas.\n\n\n\n\nProvide the connector parameter list. In order to connect to GitHub APIs, this connector uses an authenticated user and a token obtained for that user.  Furthermore, you need to initialize the connection to the GitHub API as shown below.\n    \npublic connector ClientConnector (string username, string token) {\n         endpoint\nhttp:HttpClient\n gitEP { create http:HttpClient(\"https://api.github.com\", {});}\n    }\n\n\nPrepare the base64 encoded key value to be sent in authorization header to the back end. The Ballerina built-in base64encoder is used for this purpose and the logic in this scenario is written in another function that resides in the same package as the connector.\n    \npackage org.wso2.ballerina.connectors.github;\n    import ballerina.util;\n    function getBase64EncodedKey (string value1,string value2) (string encodedString) {\n        string toEncode = value1 + \":\" + value2;\n        encodedString = \nstring\nutil:base64encode(toEncode);\n        return;\n    }\n\n\nThe above function is called within the connector to obtain the encoded string as shown below.\n    \npublic connector ClientConnector (string username, string token) {\n    endpoint\nhttp:HttpClient\n gitEP { create http:HttpClient(\"https://api.github.com\", {});}\n    string authHeader = getBase64EncodedKey(username, token);\n    }\n\n\nThe first action retrieves the list of repositories per organization. The action defined takes in the desired organization as a parameter and returns a HTTP response and, within the action, the relevant REST API is invoked.\n    \naction getReposOfOrg (string orgnization) (http:Response, http:HttpConnectorError) {\n        http:Request request = {};\n        string gitPath = string `/orgs/{{orgnization}}/repos`;\n        request.setHeader(\"Authorization\", \"Basic \"+ authHeader);\n        http:Response response = {};\n        http:HttpConnectorError err;\n        response, err = gitEP.get(gitPath, request);\n        return response, err;}\n\n    Other actions can be configured in a similar manner.\n\n\n\n\nUsing the connector\n\n\nIn order to test the connector, you must have a Ballerina program with either a main function or a service. This tutorial uses a service for the purpose. This test service is created in another package.\n\n\n\n\nImport the client connector made above to the file where the service is written.\n    \npackage com.test.sample;\n    import org.wso2.ballerina.connectors.github;\n\n\nInside a resource initialize and invoke the client connector as follows.\n    \nresource getReposForOrganization (http:Request req,http:Response res, string org) {\n        endpoint\ngithub:ClientConnector\n gitHubConnector{\n        }\n        string username = req.getHeader(\"Username\");\n        string tokenEnc = req.getHeader(\"Token\");\n        github:ClientConnector gitHubConn = create github:ClientConnector(username, tokenEnc);\n        bind gitHubConn with gitHubConnector;\n        http:Response gitHubResponse = {};\n        gitHubResponse, _ = gitHubConnector.getReposOfOrg(org);\n        res.forward(gitHubResponse);\n            }\n\nThe following is the full code of the sample.\n\n\n\n\npackage org.wso2.ballerina.connectors.github;\n\nimport ballerina.net.http;\n\n@Description {\n    value:\nGitHub Client Connector\n\n}\n@Param {\n    value:\nusername: github username\n\n}\n@Param {\n    value:\ntoken: github personal token\n\n}\npublic connector ClientConnector (string username, string token) {\n    endpoint\nhttp:HttpClient\n gitEP { create http:HttpClient(\nhttps://api.github.com\n, {});}\n\n    string authHeader = getBase64EncodedKey(username, token);\n    @Description {\n        value:\nRetrieve repositories for the authenticated user\n\n    }\n    @Return {\n        value:\nResponse object\n\n    }\n\n    action getReposOfUser () (http:Response, http:HttpConnectorError) {\n         http:Request request = {};\n         string gitPath = \n/user/repos\n;\n         request.setHeader(\nAuthorization\n, \nBasic \n+ authHeader);\n         http:Response response = {};\n         http:HttpConnectorError err;\n         response, err = gitEP.get(gitPath, request);\n         return response, err;\n    }\n    @Description {\n        value:\nList repositories for an organization\n\n    }\n    @Param {\n        value:\norganization: name of the orgnization on which repositories should be fetched\n\n    }\n    @Return {\n        value:\nResponse object\n\n    }\n    action getReposOfOrg (string orgnization) (http:Response, http:HttpConnectorError) {\n        http:Request request = {};\n        string gitPath = string `/orgs/{{orgnization}}/repos`;\n        request.setHeader(\nAuthorization\n, \nBasic \n+ authHeader);\n        http:Response response = {};\n        http:HttpConnectorError err;\n        response, err = gitEP.get(gitPath, request);\n        return response, err;\n    }\n\n    @Description {\n        value:\nList all issues under a given repository\n\n    }\n    @Param {\n        value:\norganization: name of the orgnization on which issues should be fetched\n\n    }\n    @Return {\n        value:\nResponse object\n\n    }\n    action getIssuesOfRepoByState (string orgnization, string repository, string state) (http:Response, http:HttpConnectorError) {\n        http:Request request = {};\n        string gitPath = string `/repos/{{orgnization}}/{{repository}}/issues?state={{state}}`;\n        request.setHeader(\nAuthorization\n, \nBasic \n+ authHeader);\n        http:Response response = {};\n        http:HttpConnectorError err;\n        response, err = gitEP.get(gitPath, request);\n        return response, err;\n    }\n\n}", 
            "title": "custom-client-connector"
        }, 
        {
            "location": "/tutorials/custom-client-connector/#create-a-custom-client-connector", 
            "text": "Now that you have  written a main program  and  written a passthrough service  for integration scenarios, it is time to write a custom client connector to solve a problem.   This tutorial provides instructions on how to write a custom connector that invokes  GitHub REST APIs .   This tutorial consists of the following main sections.   About connectors and actions  About custom client connectors  Create a custom client connector    Prerequisites : Download Ballerina and set it up. For instructions on how to do this, see the  Quick Tour . Use the Quick Tour to also get an understanding of the Ballerina Composer and how it works. It is also recommended to try to  write a main program  and  write a passthrough service  before trying this out. This helps you to get familiar with Ballerina and how it can help achieve integration scenarios.", 
            "title": "Create a Custom Client Connector"
        }, 
        {
            "location": "/tutorials/custom-client-connector/#about-connectors-and-actions", 
            "text": "When integrating and making a robust application, a need arises to make messaging channels in between various interfaces and weave a structure to encompass them together. When interacting with commonly available interfaces, rather than creating the structure of the messaging channel each and every time through code, it is worth keeping a programmed unit that can be reused. This component interacts with the given interface with ease and less complexity. In a way, such a unit can be described as a facade as it will mask any complexities that exist when interacting with the real interface and can be a facade to any party connecting to the particular interface.  Ballerina brings out a concept called connectors that makes the above possible with ease. Using Ballerina connectors, a custom Ballerina implementation can be made that can be used to communicate with a given interface. This custom connector can be made out-of-the-box just using Ballerina itself. The use of these custom connectors can span from a database to a REST endpoint and can even extend to a JMS queue as the requirement demands.  Connectors represents network services that are used by a Ballerina program. The term \"network services\" here is meant in the broadest possible sense - Ballerina is designed to connect with everything from a database to a JMS queue to an OAuth protected API to LDAP servers and more. Therefore, connectors are the representation of any such remote service in Ballerina.  Graphically, connectors are modeled as a separate lifeline to represent their independent and parallel execution. However, that lifeline is not a programmable thread of execution for the Ballerina developer - it only exists to represent the remote system.  Connectors may need to have usage specific parameters and, hence, must be instantiated prior to use. For example, an HTTP connector needs at least the URL to connect to.  A connector comes with a set of actions that represent the interactions that one can have with the remote service. Actions can be one directional or bi-directional and represent blocking from the calling worker's perspective. That is, the calling thread is blocked until the action has completed its remote interaction.  A connector contains the following syntax in Ballerina.  [ConnectorAnnotations]\n[public] connector ConnectorName ([Connector initialize parameters]) {\n    VariableDeclaration;*\n    ActionDefinition;+\n}  Any variables declared at the connector level is visible to all actions. The lifetime of the connector also defines the lifetime of the variables and they are local to each connector instance.  The structure of an action definition is as follows.  [ActionAnnotations]\naction actionName ([Input parameters]) ([Output parameters]){\n}  The execution semantics of an action are the same as that of a function: it runs using the caller's thread and the caller blocks until the action completes execution.", 
            "title": "About connectors and actions"
        }, 
        {
            "location": "/tutorials/custom-client-connector/#about-custom-client-connectors", 
            "text": "When creating a custom client connector, you need to be aware of the following.   The capabilities you need to expose through the connector and logical separation. These is represented by separate actions when the connector is being created.  Supportive extensions needed. These can be achieved by Ballerina itself or by integrating to an existing entity through Ballerina  Packaging the connector    In order to demonstrate the above aspects, this tutorial uses a connector that can invoke GitHub REST APIs. GitHub contains a set of REST APIs that can be used to achieve a vast set of functionalities. Out of the collection, REST APIs that cover the following functionalities are used.   View repositories for the authenticated user .  List repositories for an organization .  List issues per repository according to the state   The above can be categorized as the capabilities expected from the connector and these are represented by separate actions.  Furthermore, in order to invoke the APIs, an authentication header must be sent that encompasses the base64 encoded value of the username and the token. This is a supportive extension and can be powered by Ballerina itself by using its inbuilt  base64encoder .  After creating the connector, you need to package it in a way that the connector can be distributed. As a comprehensive packaging mechanism is work in progress, currently we will be using the available packaging model to demonstrate the usage of the connector. The reason for using the package is that, when the inbuilt packaging is available, the structure available now can be extended and packaged to a distributable mode.", 
            "title": "About custom client connectors"
        }, 
        {
            "location": "/tutorials/custom-client-connector/#create-a-custom-client-connector_1", 
            "text": "This section of the tutorial explains the way a sample custom client connector is built.    On the tool palette, click  More Connectors  to see a list of all available connectors.\n        From the list that appears, expand  ballerina.net.http  and drag a  ClientConnector  onto the canvas.   Provide the connector parameter list. In order to connect to GitHub APIs, this connector uses an authenticated user and a token obtained for that user.  Furthermore, you need to initialize the connection to the GitHub API as shown below.\n     public connector ClientConnector (string username, string token) {\n         endpoint http:HttpClient  gitEP { create http:HttpClient(\"https://api.github.com\", {});}\n    }  Prepare the base64 encoded key value to be sent in authorization header to the back end. The Ballerina built-in base64encoder is used for this purpose and the logic in this scenario is written in another function that resides in the same package as the connector.\n     package org.wso2.ballerina.connectors.github;\n    import ballerina.util;\n    function getBase64EncodedKey (string value1,string value2) (string encodedString) {\n        string toEncode = value1 + \":\" + value2;\n        encodedString =  string util:base64encode(toEncode);\n        return;\n    }  The above function is called within the connector to obtain the encoded string as shown below.\n     public connector ClientConnector (string username, string token) {\n    endpoint http:HttpClient  gitEP { create http:HttpClient(\"https://api.github.com\", {});}\n    string authHeader = getBase64EncodedKey(username, token);\n    }  The first action retrieves the list of repositories per organization. The action defined takes in the desired organization as a parameter and returns a HTTP response and, within the action, the relevant REST API is invoked.\n     action getReposOfOrg (string orgnization) (http:Response, http:HttpConnectorError) {\n        http:Request request = {};\n        string gitPath = string `/orgs/{{orgnization}}/repos`;\n        request.setHeader(\"Authorization\", \"Basic \"+ authHeader);\n        http:Response response = {};\n        http:HttpConnectorError err;\n        response, err = gitEP.get(gitPath, request);\n        return response, err;} \n    Other actions can be configured in a similar manner.", 
            "title": "Create a custom client connector"
        }, 
        {
            "location": "/tutorials/custom-client-connector/#using-the-connector", 
            "text": "In order to test the connector, you must have a Ballerina program with either a main function or a service. This tutorial uses a service for the purpose. This test service is created in another package.   Import the client connector made above to the file where the service is written.\n     package com.test.sample;\n    import org.wso2.ballerina.connectors.github;  Inside a resource initialize and invoke the client connector as follows.\n     resource getReposForOrganization (http:Request req,http:Response res, string org) {\n        endpoint github:ClientConnector  gitHubConnector{\n        }\n        string username = req.getHeader(\"Username\");\n        string tokenEnc = req.getHeader(\"Token\");\n        github:ClientConnector gitHubConn = create github:ClientConnector(username, tokenEnc);\n        bind gitHubConn with gitHubConnector;\n        http:Response gitHubResponse = {};\n        gitHubResponse, _ = gitHubConnector.getReposOfOrg(org);\n        res.forward(gitHubResponse);\n            } \nThe following is the full code of the sample.   package org.wso2.ballerina.connectors.github;\n\nimport ballerina.net.http;\n\n@Description {\n    value: GitHub Client Connector \n}\n@Param {\n    value: username: github username \n}\n@Param {\n    value: token: github personal token \n}\npublic connector ClientConnector (string username, string token) {\n    endpoint http:HttpClient  gitEP { create http:HttpClient( https://api.github.com , {});}\n\n    string authHeader = getBase64EncodedKey(username, token);\n    @Description {\n        value: Retrieve repositories for the authenticated user \n    }\n    @Return {\n        value: Response object \n    }\n\n    action getReposOfUser () (http:Response, http:HttpConnectorError) {\n         http:Request request = {};\n         string gitPath =  /user/repos ;\n         request.setHeader( Authorization ,  Basic  + authHeader);\n         http:Response response = {};\n         http:HttpConnectorError err;\n         response, err = gitEP.get(gitPath, request);\n         return response, err;\n    }\n    @Description {\n        value: List repositories for an organization \n    }\n    @Param {\n        value: organization: name of the orgnization on which repositories should be fetched \n    }\n    @Return {\n        value: Response object \n    }\n    action getReposOfOrg (string orgnization) (http:Response, http:HttpConnectorError) {\n        http:Request request = {};\n        string gitPath = string `/orgs/{{orgnization}}/repos`;\n        request.setHeader( Authorization ,  Basic  + authHeader);\n        http:Response response = {};\n        http:HttpConnectorError err;\n        response, err = gitEP.get(gitPath, request);\n        return response, err;\n    }\n\n    @Description {\n        value: List all issues under a given repository \n    }\n    @Param {\n        value: organization: name of the orgnization on which issues should be fetched \n    }\n    @Return {\n        value: Response object \n    }\n    action getIssuesOfRepoByState (string orgnization, string repository, string state) (http:Response, http:HttpConnectorError) {\n        http:Request request = {};\n        string gitPath = string `/repos/{{orgnization}}/{{repository}}/issues?state={{state}}`;\n        request.setHeader( Authorization ,  Basic  + authHeader);\n        http:Response response = {};\n        http:HttpConnectorError err;\n        response, err = gitEP.get(gitPath, request);\n        return response, err;\n    }\n\n}", 
            "title": "Using the connector"
        }, 
        {
            "location": "/tutorials/main-program/", 
            "text": "Write a Main Program\n\n\nNow that you have \nwritten your first program\n, you can write some more programs to do various integration-related tasks. \n\n\n\n\nThis tutorial provides instructions on how to write a main program. This involves a simple integration scenario where you can call a public weather forecast API and do some customization to the data obtained. The weather forecast API provides the weather forecast for the next five days and provides new records every three hours. Using this data, you will learn how to use Ballerina to find the average temperature and convert the result from Kelvin to Celsius.\n\n\n\n\nThis tutorial consists of the following main sections.\n\n\n\n\nCreate a new main program\n\n\nAdd a connector\n\n\nCall the connector\n\n\nView the response\n\n\nExtract content from JSON\n\n\nCalculate average temperature\n\n\nConvert Kelvin to Celcius\n\n\nCall the function and print the result\n\n\nGet information from the weather forecast API\n\n\nWhats Next\n\n\n\n\n\n\nPrerequisites\n: Download Ballerina and set it up. For instructions on how to do this, see the \nQuick Tour\n. For more information on the weather forecast API, see \nGet information from the weather forecast API\n.\n\n\n\n\nCreate a new main program\n\n\nThere are main programs and services, but this tutorial focuses on main programs only. A service normally continues to run and can be invoked by a REST API when required. A main program, on the other hand, will just run once. Main programs can be executed just like a Java main program. \n\n\nIt is time to create a main program to solve your integration problem.\n\n\n\n\nIf the Composer is not already running, run it as described in the \nQuick Tour\n.\n\n\nOn the Welcome page, click \nFile\n and select \nNew\n from the dropdown list.\n\n\nOn the tool palette that you see on the left of the Composer, click the \nMain Function\n icon and drag it to the canvas.\n\n\n\n\n\n\nAdd a connector\n\n\nNow that you have added a main program, you need a connector to connect to the external weather API. The connector ideal for this is the \nHTTP Client Connector\n since you are invoking an HTTP endpoint.\n\n\nConnectors represents network services that are used by a Ballerina program. The term \"network services\" here is meant in the broadest possible sense - Ballerina is designed to connect with everything from a database to a JMS queue to an OAuth protected API to LDAP servers and more. Thus connectors are the representation of any such remote service in Ballerina.\n\n\nGraphically, connectors are modeled as a separate lifeline to represent its independent and parallel execution. However, that lifeline is not a programmable thread of execution for the Ballerina developer - it only exists to represent the remote system.\n\n\nConnectors may need to have usage specific parameters and hence must be instantiated prior to use. For example, an HTTP connector will need the URL to connect to in the minimum.\n\n\n\n\nOn the tool palette, click \nMore Connectors\n to see a list of all available connectors.\n    \n\n\nFrom the list that appears, expand \nballerina.net.http\n and drag a \nClientConnector\n onto the canvas.\n    \n\n\nAdd the endpoint URL (http://api.openweathermap.org/data/2.5/forecast?appid=f6f43202ba90c14ab13479aa2a2beefb\nq=Washington,US) within quotation marks \"\" as the connector endpoint. You can also change the name of the endpoint to something suitable. For more information on how to get this URL and call it to get the JSON content, see \nGet information from the weather forecast API\n.\n    \n\n\n\n\nCall the connector\n\n\nWhen you add a connector, you need to have a way of calling a connector and those are called actions.\n\n\nA connector comes with a set of actions that represent the interactions that one can have with the remote service. Actions can be one directional or bi-directional and represent blocking from the calling worker's perspective. That is, the calling thread is blocked until the action has completed its remote interaction.\n\n\nIn the case of the HTTP connector you are using in this tutorial, the actions are listed out under the connector in the tool palette.\n\n\n\n\n\n\nAdd an action by dragging one of the actions from the tool palette onto the canvas. In this instance, you need to add a GET action as this is a GET request to the weather forecast API. Place the GET action under the main program you added.\n    \n    \n\n\nTo call the connector from the main program, draw an arrow to the connector from the action.\n    \n\n\n\n\nYou also need to pass a message to the connector from the main program. To do this, you must first add a variable.\n\n\n\n1. Define a message in the variable you just added. Curly brackets \n{}\n are used to denote an empty message. The default message is defined as the letter \nm\n.\n\n\n\n\nThe \nmessage\n type is an opaque type used to represent a request to a \nresource\n. This approach allows the \nresource\n to be network-protocol independent, even though a given \nresource\n is always tied to a particular protocol because a \nservice\n can only be bound to one network protocol at a time.\n\n\n\n\n\n\nThe GET request action for the HTTP connector requires you to pass some parameters in the request. This includes the connector, the request path, and the message. In this tutorial, forecastAPI is the name of the connector that is passed. The request path is an additional string that can be passed in the request. You can set this up so that the request path includes the API key and country code. This will be portrayed in a different tutorial. In this instance, an empty string is passed \n\"\"\n. Additionally, you can pass the message \nm\n.\n    \n\n\n\n\n\n\nView the response\n\n\nPrior to doing further changes, you can view the output to see if the call to the API works.\n\n\n\n\n\n\nYou can print the message to see the output of what you have set up. To do this, you need to find a print function. You can use the search at the top of the tool palette for this, or you can click \nMore Libraries\n and find it under the \nballerina.lang.system\n library.\n\n\n\n1. Drag and drop the print function onto the main program and print message \nm\n.\n\n\n1. Save your file by clicking \nFile\n and \nSave As\n. Provide an appropriate name for you \n.bal\n file.\n1. Click the \nRun\n button and click \nApplication\n to run this file. You can see the output in the console of the Ballerina Composer.\n\n\n\n\n\n\nThe output contains a JSON payload. This tutorial aims to access the JSON payload and extract the contents under \nlist\n. This enables you to obtain the temperature forecast in Kelvin for the next five days. For more information, see \nCall the API using the URL\n.\n\n\nOnce you have viewed this, you can remove the \nprint\n function by hovering over it and clicking the trash can icon.\n\n\nExtract content from JSON\n\n\nThe next step is to obtain the JSON payload content. \n\n\nJSON is a textual format for representing a collection of values: a simple value (string, number, \u201ctrue\u201d, \u201cfalse\u201d, \u201cnull\u201d), an array of values or an object. Ballerina also understands the JSON Schema and allows one to declare that a JSON document must conform to a particular schema.\n\n\nBallerina has a variable type named \u201cjson\u201d that can represent any JSON value. Thus it is a built-in union type in Ballerina whose value can be any one of a string, a float, a boolean, an array of any or a map of any. We provide utility functions to read a JSON document to create a JSON typed value. The lexical representation of a value of that type is JSON, thus simply printing a JSON typed variable results in a JSON string.\n\n\nJSON variables are declared in the following way:\n\n\njson VariableName;\n\n\n\n\nThis is a variable that may hold any JSON document.\n\n\n\n\nUse the search, or navigate to a function called \ngetJsonPayload\n, which is in the \nballerina.lang.messages\n library. This library contains functions that enable you to modify and use messages in various ways.\n\n\nDrag and drop this onto the main program in the canvas. This automatically applies this function on message \nm\n since that is the default message.\n    \n\n\nModify the name of the JSON function you added to something meaningful.\n    \n\n\nTo get the data under list, you need to add a variable from the tool palette to the main function in the canvas.\n    \n\n\nModify the variable so that you can get the data under list. In this example, \n.list\n is a JSON path. \n    \n\n    \n The dot notation (\n.\n) enables you to invoke any of the attributes available in the JSON. These JSON paths can be used to access the contents of an attribute. For example, if \njson j = {a:\"hello\"}\n you can access \nhello\n using \nj.a\n. When considering the example used in this tutorial, if \njson j = {list:[1,2,3]}\n you can access the list using \nj.list\n. This is done because all the content that you need resides within the list attribute in the JSON file.\n\n\n\n\nCalculate average temperature\n\n\nNow that you have extracted the content from the JSON, Ballerina needs to do the calculations. This involves using a conditional statement like \nwhile\n.\n\n\nA \nwhile\n statement provides a way to execute a series of statements as long as a Boolean expression is met. In the Composer, you can drag the \nWhile\n icon from the tool palette to the canvas to add the statement to your program. \n\n\nA \nwhile\n statement is defined as follows:\n\n\nwhile (BooleanExpression) {\n    Statement;+\n}\n\n\n\n\n\n\n\n\nAdd a \nvariable\n and define an integer that gets the number of instances of the data. Set this as \nint dataCount = jsons:getInt(forcastDataList,\"$.length()\")\n. The weather API lists multiple instances of the temperature and this variable ensures that you find the number of instances of the temperature in the data sets and assigns it to \ndataCount\n.\n\n\n\n\n\n\nYou use a \n.length\n JSON path here to access an inbuilt function of the JSON. In this case, length is an inbuilt function of JSON.\n\n\n\n\n\n\n\n\nAdd another \nvariable\n called \nint i = 0\n by dragging a variable from the tool palette to the canvas. You can use this integer to get the exact number of instances of the data you need to do the calculation.\n\n\n\n\nDrag and drop a \nwhile\n statement from the tool palette to the canvas.\n    \n\n\n\n\nSet the \nwhile\n condition to \ni \n dataCount\n to make this condition loop until it reaches the \ndataCount\n value.\n\n\n\n1. Add an \nassignment\n to the \nwhile\n loop by dragging it from the tool palette to the canvas.\n\n\n1. Specify the assignment value as \ni = i + 1\n. This increments \ni\n until it is equal to the \ndataCount\n. So if there are 5 data sets, \ni\n will be 5 when it comes out of the \nwhile\n loop.\n\n\n\n1. Add a \nvariable\n and declare it as a \nfloat\n. A \nfloat\n supports 64-bit IEEE754 arithmetic. The sum of all the temperatures can be assigned to this value type.\n\n\n\n1. Add another \nvariable\n and declare the value calculated as a \nfloat\n. This must be inside the \nwhile\n condition. This is used to calculate the temperature for each data set. In this case, \nforecastDataList[i].main.temp\n is basically used to get the temperature from the JSON for each data set. This is then assigned to the \nfloat\n using the \nfloat\n statement. The whole thing is assigned to the variable \ntemp\n.\n\n\n\n1. Add another assignment to add each temperature value the \nsumTemp\n float that was declared earlier.\n\n\n1. Add an assignment to calculate the average temperature. This is done by dividing the sum of all the temperatures by the number of temperatures or the \ndataCount\n.\n\n\n\n\n\n\n\nConvert Kelvin to Celcius\n\n\nThe next aspect of this tutorial is to convert the average temperature from Kelvin to Celcius.\n\n\n\n\nAdd a \nfunction\n by dragging it from the tool palette to the canvas. A function is a single operation that is intended to be a unit of reusable functionality. You can define additional functions within your Ballerina programs. All library functions are found in \nballerina.*\n packages under the \nsrc\n directory in your Ballerina distribution. If the function is in another package and is marked public, you can import that package using the Imports box in the upper left corner of the canvas, and then drag the Function Invocation icon to the canvas. All functions are private to the package unless explicitly declared to be public with the \npublic\n keyword. You can invoke functions from a resource or a function within the same package without importing.\n    \n\n\nProvide a name for the \nfunction\n and also add a parameter called \nfloat KelvinTemp\n that returns a \nfloat\n value. \n    \n\n\nAdd a \nreturn\n statement by dragging it from the tool palette to the canvas. The \nreturn\n statement evaluates the expression, stops the current function, and returns the result of the expression to the caller.\n    \n\n\n\n\nIn the \nreturn\n statement, do the calculation to convert Kelvin to Celcius by subtracting 273.15 from the Kelvin temperature.\n\n\n\n\n\n\n\n\nCall the function and print the result\n\n\nOnce the function is added, it is available on the tool palette and can be dragged onto the canvas when you need to call it.\n\n\n\n\n\n\n\n\nDrag the function you created onto the canvas, assign a float value, and apply the function on the average Celcius temperature.\n\n\n\n1. Drag two \nprintln\n functions to the canvas and assign \navgTemp\n to one to display the average temperature in Kelvin and assign \ncelciusTemp\n to the other to display the average temperature in Celcius.\n\n\n1. Run the main program as an application. You will see the following output in the console.\n\n\n\n\n\n\n\nGet information from the weather forecast API\n\n\nIn order to get this tutorial to work, you need to obtain some information from the public API for use in Ballerina. This section showcases how to get the URL and how to call it.\n\n\nGet the API key\n\n\nYou can access the weather forecast API and obtain the API key from it using the following steps. The key is used as part of the URL that is called by Ballerina.\n\n\n\n\nGo to https://openweathermap.org/ and click \nSign Up\n to register your account.\n\n\nOnce you have signed up for an account, log in using your credentials.\n\n\nIn the home page that appears, click \nAPI keys\n. You can copy the \nKey\n that is already generated for you.\n\n\n\n\n\n\nIdentify the country code\n\n\nThe weather forecast API can be done for any country. Washington (USA) is used in our example. You need to identify the exact code to use to pass this parameter in the URL.\n\n\n\n\nClick \nAPI\n in the top level menu and click the \nAPI doc\n button under \n5 day / 3 hour forecast\n.\n    \n\n\nThe page that appears provides details about the API and provides sample calls for different types of requirements. Under the \nBy city ID\n section, you can access a JSON file from http://bulk.openweathermap.org/sample/. This includes all the country codes available.\n    \n\n\n\n\nCall the API using the URL\n\n\nNow that you have got the API key and the country code, you can identify the URL that you need to call from Ballerina. The URL is something similar to the following: http://api.openweathermap.org/data/2.5/forecast?appid=f6f43202ba90c14ab13479aa2a2beefb\nq=Washington,US.\n\n\n\n\nHere the \nappid\n is the API key and the country code is \nWashington,US\n.\n\n\n\n\nUse a tool that can interact with HTTP APIs. In this instance we use Postman, which is a Google Chrome app. Paste the URL above in the \nEnter request URL\n text box and change the request type to \nGET\n. In the JSON response you can see the \nlist\n part of the response contans the temperature (\ntemp\n) in Kelvin.\n\n\n\n\nWhats Next\n\n\nNow that you have learnt how to write a main program, it is time to learn how to \nwork with services\n.", 
            "title": "main-program"
        }, 
        {
            "location": "/tutorials/main-program/#write-a-main-program", 
            "text": "Now that you have  written your first program , you can write some more programs to do various integration-related tasks.    This tutorial provides instructions on how to write a main program. This involves a simple integration scenario where you can call a public weather forecast API and do some customization to the data obtained. The weather forecast API provides the weather forecast for the next five days and provides new records every three hours. Using this data, you will learn how to use Ballerina to find the average temperature and convert the result from Kelvin to Celsius.   This tutorial consists of the following main sections.   Create a new main program  Add a connector  Call the connector  View the response  Extract content from JSON  Calculate average temperature  Convert Kelvin to Celcius  Call the function and print the result  Get information from the weather forecast API  Whats Next    Prerequisites : Download Ballerina and set it up. For instructions on how to do this, see the  Quick Tour . For more information on the weather forecast API, see  Get information from the weather forecast API .", 
            "title": "Write a Main Program"
        }, 
        {
            "location": "/tutorials/main-program/#create-a-new-main-program", 
            "text": "There are main programs and services, but this tutorial focuses on main programs only. A service normally continues to run and can be invoked by a REST API when required. A main program, on the other hand, will just run once. Main programs can be executed just like a Java main program.   It is time to create a main program to solve your integration problem.   If the Composer is not already running, run it as described in the  Quick Tour .  On the Welcome page, click  File  and select  New  from the dropdown list.  On the tool palette that you see on the left of the Composer, click the  Main Function  icon and drag it to the canvas.", 
            "title": "Create a new main program"
        }, 
        {
            "location": "/tutorials/main-program/#add-a-connector", 
            "text": "Now that you have added a main program, you need a connector to connect to the external weather API. The connector ideal for this is the  HTTP Client Connector  since you are invoking an HTTP endpoint.  Connectors represents network services that are used by a Ballerina program. The term \"network services\" here is meant in the broadest possible sense - Ballerina is designed to connect with everything from a database to a JMS queue to an OAuth protected API to LDAP servers and more. Thus connectors are the representation of any such remote service in Ballerina.  Graphically, connectors are modeled as a separate lifeline to represent its independent and parallel execution. However, that lifeline is not a programmable thread of execution for the Ballerina developer - it only exists to represent the remote system.  Connectors may need to have usage specific parameters and hence must be instantiated prior to use. For example, an HTTP connector will need the URL to connect to in the minimum.   On the tool palette, click  More Connectors  to see a list of all available connectors.\n      From the list that appears, expand  ballerina.net.http  and drag a  ClientConnector  onto the canvas.\n      Add the endpoint URL (http://api.openweathermap.org/data/2.5/forecast?appid=f6f43202ba90c14ab13479aa2a2beefb q=Washington,US) within quotation marks \"\" as the connector endpoint. You can also change the name of the endpoint to something suitable. For more information on how to get this URL and call it to get the JSON content, see  Get information from the weather forecast API .", 
            "title": "Add a connector"
        }, 
        {
            "location": "/tutorials/main-program/#call-the-connector", 
            "text": "When you add a connector, you need to have a way of calling a connector and those are called actions.  A connector comes with a set of actions that represent the interactions that one can have with the remote service. Actions can be one directional or bi-directional and represent blocking from the calling worker's perspective. That is, the calling thread is blocked until the action has completed its remote interaction.  In the case of the HTTP connector you are using in this tutorial, the actions are listed out under the connector in the tool palette.    Add an action by dragging one of the actions from the tool palette onto the canvas. In this instance, you need to add a GET action as this is a GET request to the weather forecast API. Place the GET action under the main program you added.\n           To call the connector from the main program, draw an arrow to the connector from the action.\n       You also need to pass a message to the connector from the main program. To do this, you must first add a variable.  \n1. Define a message in the variable you just added. Curly brackets  {}  are used to denote an empty message. The default message is defined as the letter  m .   The  message  type is an opaque type used to represent a request to a  resource . This approach allows the  resource  to be network-protocol independent, even though a given  resource  is always tied to a particular protocol because a  service  can only be bound to one network protocol at a time.    The GET request action for the HTTP connector requires you to pass some parameters in the request. This includes the connector, the request path, and the message. In this tutorial, forecastAPI is the name of the connector that is passed. The request path is an additional string that can be passed in the request. You can set this up so that the request path includes the API key and country code. This will be portrayed in a different tutorial. In this instance, an empty string is passed  \"\" . Additionally, you can pass the message  m .", 
            "title": "Call the connector"
        }, 
        {
            "location": "/tutorials/main-program/#view-the-response", 
            "text": "Prior to doing further changes, you can view the output to see if the call to the API works.    You can print the message to see the output of what you have set up. To do this, you need to find a print function. You can use the search at the top of the tool palette for this, or you can click  More Libraries  and find it under the  ballerina.lang.system  library.  \n1. Drag and drop the print function onto the main program and print message  m . \n1. Save your file by clicking  File  and  Save As . Provide an appropriate name for you  .bal  file.\n1. Click the  Run  button and click  Application  to run this file. You can see the output in the console of the Ballerina Composer.    The output contains a JSON payload. This tutorial aims to access the JSON payload and extract the contents under  list . This enables you to obtain the temperature forecast in Kelvin for the next five days. For more information, see  Call the API using the URL .  Once you have viewed this, you can remove the  print  function by hovering over it and clicking the trash can icon.", 
            "title": "View the response"
        }, 
        {
            "location": "/tutorials/main-program/#extract-content-from-json", 
            "text": "The next step is to obtain the JSON payload content.   JSON is a textual format for representing a collection of values: a simple value (string, number, \u201ctrue\u201d, \u201cfalse\u201d, \u201cnull\u201d), an array of values or an object. Ballerina also understands the JSON Schema and allows one to declare that a JSON document must conform to a particular schema.  Ballerina has a variable type named \u201cjson\u201d that can represent any JSON value. Thus it is a built-in union type in Ballerina whose value can be any one of a string, a float, a boolean, an array of any or a map of any. We provide utility functions to read a JSON document to create a JSON typed value. The lexical representation of a value of that type is JSON, thus simply printing a JSON typed variable results in a JSON string.  JSON variables are declared in the following way:  json VariableName;  This is a variable that may hold any JSON document.   Use the search, or navigate to a function called  getJsonPayload , which is in the  ballerina.lang.messages  library. This library contains functions that enable you to modify and use messages in various ways.  Drag and drop this onto the main program in the canvas. This automatically applies this function on message  m  since that is the default message.\n      Modify the name of the JSON function you added to something meaningful.\n      To get the data under list, you need to add a variable from the tool palette to the main function in the canvas.\n      Modify the variable so that you can get the data under list. In this example,  .list  is a JSON path. \n     \n      The dot notation ( . ) enables you to invoke any of the attributes available in the JSON. These JSON paths can be used to access the contents of an attribute. For example, if  json j = {a:\"hello\"}  you can access  hello  using  j.a . When considering the example used in this tutorial, if  json j = {list:[1,2,3]}  you can access the list using  j.list . This is done because all the content that you need resides within the list attribute in the JSON file.", 
            "title": "Extract content from JSON"
        }, 
        {
            "location": "/tutorials/main-program/#calculate-average-temperature", 
            "text": "Now that you have extracted the content from the JSON, Ballerina needs to do the calculations. This involves using a conditional statement like  while .  A  while  statement provides a way to execute a series of statements as long as a Boolean expression is met. In the Composer, you can drag the  While  icon from the tool palette to the canvas to add the statement to your program.   A  while  statement is defined as follows:  while (BooleanExpression) {\n    Statement;+\n}    Add a  variable  and define an integer that gets the number of instances of the data. Set this as  int dataCount = jsons:getInt(forcastDataList,\"$.length()\") . The weather API lists multiple instances of the temperature and this variable ensures that you find the number of instances of the temperature in the data sets and assigns it to  dataCount .    You use a  .length  JSON path here to access an inbuilt function of the JSON. In this case, length is an inbuilt function of JSON.     Add another  variable  called  int i = 0  by dragging a variable from the tool palette to the canvas. You can use this integer to get the exact number of instances of the data you need to do the calculation.   Drag and drop a  while  statement from the tool palette to the canvas.\n       Set the  while  condition to  i   dataCount  to make this condition loop until it reaches the  dataCount  value.  \n1. Add an  assignment  to the  while  loop by dragging it from the tool palette to the canvas. \n1. Specify the assignment value as  i = i + 1 . This increments  i  until it is equal to the  dataCount . So if there are 5 data sets,  i  will be 5 when it comes out of the  while  loop.  \n1. Add a  variable  and declare it as a  float . A  float  supports 64-bit IEEE754 arithmetic. The sum of all the temperatures can be assigned to this value type.  \n1. Add another  variable  and declare the value calculated as a  float . This must be inside the  while  condition. This is used to calculate the temperature for each data set. In this case,  forecastDataList[i].main.temp  is basically used to get the temperature from the JSON for each data set. This is then assigned to the  float  using the  float  statement. The whole thing is assigned to the variable  temp .  \n1. Add another assignment to add each temperature value the  sumTemp  float that was declared earlier. \n1. Add an assignment to calculate the average temperature. This is done by dividing the sum of all the temperatures by the number of temperatures or the  dataCount .", 
            "title": "Calculate average temperature"
        }, 
        {
            "location": "/tutorials/main-program/#convert-kelvin-to-celcius", 
            "text": "The next aspect of this tutorial is to convert the average temperature from Kelvin to Celcius.   Add a  function  by dragging it from the tool palette to the canvas. A function is a single operation that is intended to be a unit of reusable functionality. You can define additional functions within your Ballerina programs. All library functions are found in  ballerina.*  packages under the  src  directory in your Ballerina distribution. If the function is in another package and is marked public, you can import that package using the Imports box in the upper left corner of the canvas, and then drag the Function Invocation icon to the canvas. All functions are private to the package unless explicitly declared to be public with the  public  keyword. You can invoke functions from a resource or a function within the same package without importing.\n      Provide a name for the  function  and also add a parameter called  float KelvinTemp  that returns a  float  value. \n      Add a  return  statement by dragging it from the tool palette to the canvas. The  return  statement evaluates the expression, stops the current function, and returns the result of the expression to the caller.\n       In the  return  statement, do the calculation to convert Kelvin to Celcius by subtracting 273.15 from the Kelvin temperature.", 
            "title": "Convert Kelvin to Celcius"
        }, 
        {
            "location": "/tutorials/main-program/#call-the-function-and-print-the-result", 
            "text": "Once the function is added, it is available on the tool palette and can be dragged onto the canvas when you need to call it.     Drag the function you created onto the canvas, assign a float value, and apply the function on the average Celcius temperature.  \n1. Drag two  println  functions to the canvas and assign  avgTemp  to one to display the average temperature in Kelvin and assign  celciusTemp  to the other to display the average temperature in Celcius. \n1. Run the main program as an application. You will see the following output in the console.", 
            "title": "Call the function and print the result"
        }, 
        {
            "location": "/tutorials/main-program/#get-information-from-the-weather-forecast-api", 
            "text": "In order to get this tutorial to work, you need to obtain some information from the public API for use in Ballerina. This section showcases how to get the URL and how to call it.", 
            "title": "Get information from the weather forecast API"
        }, 
        {
            "location": "/tutorials/main-program/#get-the-api-key", 
            "text": "You can access the weather forecast API and obtain the API key from it using the following steps. The key is used as part of the URL that is called by Ballerina.   Go to https://openweathermap.org/ and click  Sign Up  to register your account.  Once you have signed up for an account, log in using your credentials.  In the home page that appears, click  API keys . You can copy the  Key  that is already generated for you.", 
            "title": "Get the API key"
        }, 
        {
            "location": "/tutorials/main-program/#identify-the-country-code", 
            "text": "The weather forecast API can be done for any country. Washington (USA) is used in our example. You need to identify the exact code to use to pass this parameter in the URL.   Click  API  in the top level menu and click the  API doc  button under  5 day / 3 hour forecast .\n      The page that appears provides details about the API and provides sample calls for different types of requirements. Under the  By city ID  section, you can access a JSON file from http://bulk.openweathermap.org/sample/. This includes all the country codes available.", 
            "title": "Identify the country code"
        }, 
        {
            "location": "/tutorials/main-program/#call-the-api-using-the-url", 
            "text": "Now that you have got the API key and the country code, you can identify the URL that you need to call from Ballerina. The URL is something similar to the following: http://api.openweathermap.org/data/2.5/forecast?appid=f6f43202ba90c14ab13479aa2a2beefb q=Washington,US.   Here the  appid  is the API key and the country code is  Washington,US .   Use a tool that can interact with HTTP APIs. In this instance we use Postman, which is a Google Chrome app. Paste the URL above in the  Enter request URL  text box and change the request type to  GET . In the JSON response you can see the  list  part of the response contans the temperature ( temp ) in Kelvin.", 
            "title": "Call the API using the URL"
        }, 
        {
            "location": "/tutorials/main-program/#whats-next", 
            "text": "Now that you have learnt how to write a main program, it is time to learn how to  work with services .", 
            "title": "Whats Next"
        }, 
        {
            "location": "/tutorials/passthrough-service/", 
            "text": "Write a Passthrough Service\n\n\nNow that you have \nwritten a main program\n for an integration scenario, it is time to work with services.\n\n\n\n\nThis tutorial provides instructions on how to write a REST service that uses the Google Books API to get books about a given topic. This scenario is demonstrated by querying books on WSO2.\n\n\n\n\nThis tutorial consists of the following main sections.\n\n\n\n\nAbout service URLs\n\n\nAdd a service\n\n\nAdd integration logic to your service\n\n\nView the Swagger definition for your service\n\n\nAdd a client connector\n\n\nCall the client connector\n\n\nExtract content from the JSON\n\n\n\n\n\n\nPrerequisites\n: Download Ballerina and set it up. For instructions on how to do this, see the \nQuick Tour\n. it is also recommended to try to \nwrite a main program\n as some concepts are explored in detail in that tutorial. It may also be useful to read and understand the section \nabout service URLs\n.\n\n\n\n\nWhen defining a Ballerina program as a service instead of an executable program, the \nservice\n construct acts as the top-level container that holds all the integration logic and can interact with the rest of the world. Its base path is the context part of the URL that clients use when sending requests to the service. You create one service per Ballerina program file.\n\n\nA service is a container of \nresources\n, each of which defines the logic for handling one type of request. Services are singletons, so all variables defined within a service scope are shared across all resource invocations. A service can have state for as long as it's active.\n\n\nAbout service URLs\n\n\nIn this tutorial, the service and the resource are also represented by the URL that you are calling. For example, the basepath for a resource can be as follows: \n\n\n\n\nhttp://localhost:9090/\n\n\n\n\nThe following is the URL for the \nbooks\n service:\n\n\n\n\nhttp://localhost:9090/books\n\n\n\n\nIf you are accessing a different service, like \nmagazines\n for example, you can have magazines instead of books in the above URL.\n\n\nIf you are accessing a resource within this service, like book titles for example, the URL is as follows:\n\n\n\n\nhttp://localhost:9090/books/title\n\n\n\n\nThis is how resources and services can equate to the URL that you are calling.\n\n\nIn addition to this, there can be a query parameter added to the title. In this scenario, you are querying books that have \"WSO2\" in the title, so the URL is as follows.\n\n\n\n\nhttp://localhost:9090/books/title?title=wso2\n\n\n\n\nAdd a service\n\n\nTo get started, add a service in the Ballerina Composer.\n\n\n\n\n\n\nTo define a service in the Composer, drag the service from the tool palette to the canvas. You can then set the base path annotation using the \nAnnotations\n button in the upper right corner of the service, and define any variables the service needs by clicking the \nVariables\n button in the upper left corner. \n\n\n\nA new resource is added automatically with the service. This happens because a resource is required if you need to invoke something or get something back from the service. \n1. You can rename the service by providing an appropriate name.\n\n\n1. You can also rename the resourse to something appropriate.\n\n\n\nYou can start adding your integration logic.\n\n\n\n\n\n\nAdd integration logic to your service\n\n\nNow that you have added a service, you must set up this service so that it can be used in your integration scenario.\n\n\n\n\nSelect an HTTP identifier from the dropdown available. In this case, you can use GET as the HTTP verb, since you are aiming to get the information using a URL. If you use both a GET and a POST, you need to add a new resource. You can add more resources by dragging them from the tool palette and adding them to the service.\n    \n\n\nAs mentioned in \nAbout service URLs\n, the path for the books service is \nhttp://localhost:9090/books\n. Add an annotation by clicking on the label in the service and selecting \nballerina.net.http\n from the dropdown.\n    \n\n\n\n\nOnce you add the annotation, you are asked to add an identifier. Select \nconfig\n as the identifier from the dropdown.\n\n\n\n1. Click the \n+\n sign and select \nbasePath\n from the dropdown to select the basepath.\n\n\n1. Enter the base path as \n/books\n to define \nhttp://localhost:9090/books\n as the service.\n\n\n1. Add an annotation to the service itself by clicking the label in the service and selecting \nballerina.net.http\n from the dropdown.\n\n\n\n1. Add a HTTP Path from the dropdown that appears.\n\n\n1. Click the \n+\n sign next to \n@Http:Path\n and select value in the dropdown that appears. Define the value as \n/title\n and assign it to the HTTP Path variable. This enables the Ballerina service and the resource to be mapped properly to the title of the book. This is linked to the URL to be called: \nhttp://localhost:9090/books/title\n.\n\n\n\n\n\n\n\nView the Swagger definition for your service\n\n\nIf your Ballerina program contains services and resources, you can view the generated Swagger definition for your program by switching to the Swagger view. All the changes made on the Swagger definition will reflect on the Ballerina program when you switch back to Source or Design view.\n\n\nYou can also import Swagger files by clicking \nFile\n in the top menu and selecting \nImport Swagger\n.\n\n\n\n\n\n\nClick the Swagger definition icon on the right of your service to view the Swagger definition. You can switch back to the \nDesign View\n or \nSource View\n by clicking the buttons at the bottom right of your screen.\n\n\n\n\nThe Swagger UI Editor provides numerous usage options to easily interact with APIs.\n\n\n1. Click \nGET\n to see the details in the Swagger UI.\n\n\n\n\n\n\n\nAdd a client connector\n\n\nNow that you have added a service, you need a connector to connect to the external books API.\n\n\n\n\nOn the tool palette, click \nMore Connectors\n to see a list of all available connectors.\n    \n\n\nFrom the list that appears, expand \nballerina.net.http\n and drag a \nClientConnector\n onto the canvas.\n    \n\n\nAdd the endpoint URL (https://www.googleapis.com/books/v1/) within quotation marks \"\" as the connector endpoint. You can also change the name of the endpoint to something suitable.\n    \n\n    \n The endpoint URL, in this instance, is not the complete URL and does not include the title or the book and other details. You can directly add the complete URL here if you wish. This is not done in this scenario for the purposes of the tutorial and to highlight a different means of achieving the same outcome, i.e., the title will be appended in the request.\n\n\n\n\nCall the client connector\n\n\n\n\nAdd a HTTP GET request by dragging it from the tool palette to the canvas.\n    \n\n\nTo call the connector from the main program, draw an arrow to the connector from the GET action.\n    \n\n\nPass a message from the main program to the connector by specifying the remaining part of the endpoint URL (volumes?q=intitle:wso2) and message \nm\n. Also rename the HTTP GET message name to \nm\n.\n    \n\n    \n Note that a message is passed by default in a service. This will not be the case in a main program application. In this case, it is message \nm\n that is passed. The full endpoint URL is https://www.googleapis.com/books/v1/volumes?q=intitle:wso2.\n\n\nAdd the query parameter to the resource by going to the source view and modifying the resource to the following.\n    \nresource getBooksByTitle (message m, @http:QueryParam {value:\"title\"} string title)\n\n\nNow that you have specified a query parameter, you can use the value of the query parameter in your connector call. Change the message passed to the following.\n    \n\n\n\n\nExtract content from the JSON\n\n\n\n\nUse the search, or navigate to a function called \ngetJsonPayload\n, which is in the \nballerina.lang.messages\n library. This library contains functions that enable you to modify and use messages in various ways.\n\n\nDrag and drop this onto the main program in the canvas. This automatically applies this function on message m since that is the default message.\n    \n\n\n\n\nRename the JSON as \nj\n.\n\n\n\n1. Add a variable from the tool palette to the main function in the canvas.\n\n\n1. Modify the variable so that you can get the data under list. In this example, \n.list\n is a JSON path. \n \njson bookList = j.items", 
            "title": "passthrough-service"
        }, 
        {
            "location": "/tutorials/passthrough-service/#write-a-passthrough-service", 
            "text": "Now that you have  written a main program  for an integration scenario, it is time to work with services.   This tutorial provides instructions on how to write a REST service that uses the Google Books API to get books about a given topic. This scenario is demonstrated by querying books on WSO2.   This tutorial consists of the following main sections.   About service URLs  Add a service  Add integration logic to your service  View the Swagger definition for your service  Add a client connector  Call the client connector  Extract content from the JSON    Prerequisites : Download Ballerina and set it up. For instructions on how to do this, see the  Quick Tour . it is also recommended to try to  write a main program  as some concepts are explored in detail in that tutorial. It may also be useful to read and understand the section  about service URLs .   When defining a Ballerina program as a service instead of an executable program, the  service  construct acts as the top-level container that holds all the integration logic and can interact with the rest of the world. Its base path is the context part of the URL that clients use when sending requests to the service. You create one service per Ballerina program file.  A service is a container of  resources , each of which defines the logic for handling one type of request. Services are singletons, so all variables defined within a service scope are shared across all resource invocations. A service can have state for as long as it's active.", 
            "title": "Write a Passthrough Service"
        }, 
        {
            "location": "/tutorials/passthrough-service/#about-service-urls", 
            "text": "In this tutorial, the service and the resource are also represented by the URL that you are calling. For example, the basepath for a resource can be as follows:    http://localhost:9090/   The following is the URL for the  books  service:   http://localhost:9090/books   If you are accessing a different service, like  magazines  for example, you can have magazines instead of books in the above URL.  If you are accessing a resource within this service, like book titles for example, the URL is as follows:   http://localhost:9090/books/title   This is how resources and services can equate to the URL that you are calling.  In addition to this, there can be a query parameter added to the title. In this scenario, you are querying books that have \"WSO2\" in the title, so the URL is as follows.   http://localhost:9090/books/title?title=wso2", 
            "title": "About service URLs"
        }, 
        {
            "location": "/tutorials/passthrough-service/#add-a-service", 
            "text": "To get started, add a service in the Ballerina Composer.    To define a service in the Composer, drag the service from the tool palette to the canvas. You can then set the base path annotation using the  Annotations  button in the upper right corner of the service, and define any variables the service needs by clicking the  Variables  button in the upper left corner.   \nA new resource is added automatically with the service. This happens because a resource is required if you need to invoke something or get something back from the service. \n1. You can rename the service by providing an appropriate name. \n1. You can also rename the resourse to something appropriate.  You can start adding your integration logic.", 
            "title": "Add a service"
        }, 
        {
            "location": "/tutorials/passthrough-service/#add-integration-logic-to-your-service", 
            "text": "Now that you have added a service, you must set up this service so that it can be used in your integration scenario.   Select an HTTP identifier from the dropdown available. In this case, you can use GET as the HTTP verb, since you are aiming to get the information using a URL. If you use both a GET and a POST, you need to add a new resource. You can add more resources by dragging them from the tool palette and adding them to the service.\n      As mentioned in  About service URLs , the path for the books service is  http://localhost:9090/books . Add an annotation by clicking on the label in the service and selecting  ballerina.net.http  from the dropdown.\n       Once you add the annotation, you are asked to add an identifier. Select  config  as the identifier from the dropdown.  \n1. Click the  +  sign and select  basePath  from the dropdown to select the basepath. \n1. Enter the base path as  /books  to define  http://localhost:9090/books  as the service. \n1. Add an annotation to the service itself by clicking the label in the service and selecting  ballerina.net.http  from the dropdown.  \n1. Add a HTTP Path from the dropdown that appears. \n1. Click the  +  sign next to  @Http:Path  and select value in the dropdown that appears. Define the value as  /title  and assign it to the HTTP Path variable. This enables the Ballerina service and the resource to be mapped properly to the title of the book. This is linked to the URL to be called:  http://localhost:9090/books/title .", 
            "title": "Add integration logic to your service"
        }, 
        {
            "location": "/tutorials/passthrough-service/#view-the-swagger-definition-for-your-service", 
            "text": "If your Ballerina program contains services and resources, you can view the generated Swagger definition for your program by switching to the Swagger view. All the changes made on the Swagger definition will reflect on the Ballerina program when you switch back to Source or Design view.  You can also import Swagger files by clicking  File  in the top menu and selecting  Import Swagger .    Click the Swagger definition icon on the right of your service to view the Swagger definition. You can switch back to the  Design View  or  Source View  by clicking the buttons at the bottom right of your screen.   The Swagger UI Editor provides numerous usage options to easily interact with APIs. \n1. Click  GET  to see the details in the Swagger UI.", 
            "title": "View the Swagger definition for your service"
        }, 
        {
            "location": "/tutorials/passthrough-service/#add-a-client-connector", 
            "text": "Now that you have added a service, you need a connector to connect to the external books API.   On the tool palette, click  More Connectors  to see a list of all available connectors.\n      From the list that appears, expand  ballerina.net.http  and drag a  ClientConnector  onto the canvas.\n      Add the endpoint URL (https://www.googleapis.com/books/v1/) within quotation marks \"\" as the connector endpoint. You can also change the name of the endpoint to something suitable.\n     \n      The endpoint URL, in this instance, is not the complete URL and does not include the title or the book and other details. You can directly add the complete URL here if you wish. This is not done in this scenario for the purposes of the tutorial and to highlight a different means of achieving the same outcome, i.e., the title will be appended in the request.", 
            "title": "Add a client connector"
        }, 
        {
            "location": "/tutorials/passthrough-service/#call-the-client-connector", 
            "text": "Add a HTTP GET request by dragging it from the tool palette to the canvas.\n      To call the connector from the main program, draw an arrow to the connector from the GET action.\n      Pass a message from the main program to the connector by specifying the remaining part of the endpoint URL (volumes?q=intitle:wso2) and message  m . Also rename the HTTP GET message name to  m .\n     \n      Note that a message is passed by default in a service. This will not be the case in a main program application. In this case, it is message  m  that is passed. The full endpoint URL is https://www.googleapis.com/books/v1/volumes?q=intitle:wso2.  Add the query parameter to the resource by going to the source view and modifying the resource to the following.\n     resource getBooksByTitle (message m, @http:QueryParam {value:\"title\"} string title)  Now that you have specified a query parameter, you can use the value of the query parameter in your connector call. Change the message passed to the following.", 
            "title": "Call the client connector"
        }, 
        {
            "location": "/tutorials/passthrough-service/#extract-content-from-the-json", 
            "text": "Use the search, or navigate to a function called  getJsonPayload , which is in the  ballerina.lang.messages  library. This library contains functions that enable you to modify and use messages in various ways.  Drag and drop this onto the main program in the canvas. This automatically applies this function on message m since that is the default message.\n       Rename the JSON as  j .  \n1. Add a variable from the tool palette to the main function in the canvas. \n1. Modify the variable so that you can get the data under list. In this example,  .list  is a JSON path. \n  json bookList = j.items", 
            "title": "Extract content from the JSON"
        }
    ]
}